# Story 4.5: Migration Execution & Fresh Start Option

## Status
Ready for Development

## Story
**As a** system administrator,
**I want** a reliable migration path from the current mixed architecture to the ingredient-first model with an option for a fresh start,
**so that** we can safely transition to the new architecture without data loss and with the ability to recover if issues occur.

## Acceptance Criteria
1. Migration utility successfully converts existing data to ingredient-first format
2. "Fresh start" mode safely resets collections with proper initialization
3. All migrations are tested in emulator before production
4. Rollback procedures are documented and tested
5. Data export/import functionality works for backup purposes
6. No data loss occurs during migration process
7. System handles both empty and populated collection states gracefully

## Tasks / Subtasks

### TDD Workflow (MANDATORY - Follow this exact order)
**Phase 1: Write Tests First**
- [ ] Write tests for data transformation logic
- [ ] Write tests for migration validation
- [ ] Write tests for fresh start collection initialization
- [ ] Write tests for empty collection handling
- [ ] Write tests for export/import functionality
- [ ] Write tests for rollback procedures
- [ ] Write integration tests for complete migration flow

**Phase 2: Make Tests Pass (Minimal Implementation)**
- [ ] Create Migration Utility (AC: 1)
  - [ ] Create scripts/migrate-to-ingredient-first.js
  - [ ] Implement data reading from old format
  - [ ] Write transformation logic to new format
  - [ ] Add validation for migrated data
  - [ ] Implement dry-run mode for testing
  - [ ] ✅ Verify migration utility tests pass

- [ ] Implement Fresh Start Mode (AC: 2, 7)
  - [ ] Create scripts/fresh-start.js
  - [ ] Add collection deletion with safety checks
  - [ ] Implement collection initialization with schema
  - [ ] Handle empty collection states in application
  - [ ] Add confirmation prompts and backups
  - [ ] ✅ Verify fresh start tests pass

- [ ] Build Export/Import Tools (AC: 5)
  - [ ] Create scripts/export-all-data.js
  - [ ] Create scripts/import-data.js
  - [ ] Add data validation on import
  - [ ] Support selective export/import
  - [ ] Implement data format versioning
  - [ ] ✅ Verify export/import tests pass

- [ ] Handle Collection State Management (AC: 7)
  - [ ] Update Firebase services to handle empty collections
  - [ ] Add collection initialization on first write
  - [ ] Implement proper error handling for missing collections
  - [ ] Add collection existence checks
  - [ ] Create default data structures
  - [ ] ✅ Verify collection state tests pass

- [ ] Create Rollback Procedures (AC: 4)
  - [ ] Document rollback steps in MIGRATION_GUIDE.md
  - [ ] Create scripts/rollback-migration.js
  - [ ] Test rollback in emulator
  - [ ] Implement automatic backup before migration
  - [ ] Add rollback verification checks
  - [ ] ✅ Verify rollback tests pass

**Phase 3: Refactor for Maintainability**
- [ ] Extract migration logic into MigrationService class (max 400 lines)
  - [ ] Create DataTransformer module (max 250 lines)
  - [ ] Create ValidationService for data integrity (max 200 lines)
  - [ ] Create BackupManager for backup operations (max 250 lines)
- [ ] Organize collection management
  - [ ] Create CollectionInitializer service (max 200 lines)
  - [ ] Create EmptyStateHandler (max 150 lines)
  - [ ] Extract schema definitions into separate modules
- [ ] Create reusable migration components
  - [ ] Create ProgressTracker for migration status (max 150 lines)
  - [ ] Create MigrationLogger for audit trail (max 100 lines)
  - [ ] Create RollbackManager for safe reversals (max 200 lines)
- [ ] ✅ Verify ALL tests still pass after refactoring
- [ ] ✅ Ensure no migration module exceeds 400 lines
- [ ] ✅ Maintain data integrity throughout refactoring
- [ ] ✅ Achieve minimum 90% test coverage for migration code

- [ ] Test Migration in Emulator (AC: 3)
  - [ ] Load production data snapshot into emulator
  - [ ] Run migration scripts against emulator
  - [ ] Verify data integrity after migration
  - [ ] Test edge cases and error scenarios
  - [ ] Performance test with large datasets

- [ ] Production Migration Execution (AC: 6)
  - [ ] Create pre-migration checklist
  - [ ] Schedule maintenance window
  - [ ] Execute backup procedures
  - [ ] Run migration with monitoring
  - [ ] Verify post-migration functionality

- [ ] Documentation and Communication (AC: 4)
  - [ ] Create docs/MIGRATION_GUIDE.md
  - [ ] Document rollback procedures
  - [ ] Create troubleshooting guide
  - [ ] Prepare user communication
  - [ ] Update operational runbooks

## Dev Notes

### Migration Context
[User reported]: "I don't mind even just deleting a lot of stuff in Firebase and starting fresh, but I worry that if I delete all the collections then I'm going to get errors because the collections don't exist."

### Migration Strategy Options
1. **Progressive Migration** (Lower Risk)
   - Run dual models temporarily
   - Migrate data incrementally
   - Switch over once stable
   
2. **Clean Slate** (Faster, Higher Risk)
   - Export valuable data
   - Reset Firebase collections
   - Import cleaned data
   - Recommended by user if done safely

### Firebase Collection Handling
[Source: architecture-shards/3-technology-stack.md#Backend Services]
- Firebase Firestore 12.0.0
- Collections are created automatically on first document write
- Empty collections don't cause errors if handled properly
- Use exists() checks before operations

### Data Structure
Current Mixed Model:
- Legacy sections in 'sections' collection
- Ingredients in 'ingredients' collection
- Possible duplicates and inconsistencies

Target Ingredient-First Model:
- Primary 'ingredients' collection
- 'sharedIngredients' for shared content
- 'baselineConfigs' for version history

### Critical Safety Measures
```javascript
// Always check collection exists
const checkCollection = async (collectionName) => {
  const snapshot = await db.collection(collectionName).limit(1).get();
  return !snapshot.empty;
};

// Initialize if needed
const initializeCollection = async (collectionName, defaultDoc) => {
  if (!await checkCollection(collectionName)) {
    await db.collection(collectionName).doc('_init').set(defaultDoc);
  }
};
```

### Migration Checklist
- [ ] Backup all data
- [ ] Test in emulator
- [ ] Verify rollback works
- [ ] Communicate to users
- [ ] Monitor during migration
- [ ] Verify post-migration
- [ ] Keep backups for 30 days

## Testing
[Source: architecture-shards/3-technology-stack.md#Development Tools]
- Unit tests for migration scripts using Vitest
- Integration tests for data transformation
- E2E tests to verify app works post-migration
- Load tests with various data volumes
- Rollback procedure testing

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-01 | 1.0 | Initial story creation | Scrum Master Bob |

## Dev Agent Record
### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_