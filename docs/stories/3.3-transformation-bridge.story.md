# Story 3.3: Build Config-to-Ingredient Transformation Bridge

## Status
Ready for Development

## Story
**As a** developer,
**I want** to create bidirectional transformation utilities between ingredient and config formats,
**So that** users can seamlessly work with both data models and maintain backward compatibility

## Acceptance Criteria
1. Preserve existing configToSections and sectionsToConfig functions
2. Add ingredientToConfig transformation for quick testing
3. Add configToIngredient extraction for migration
4. Maintain full fidelity in round-trip transformations
5. Performance optimization for transformation operations

## TDD Approach
**Following TDD Agentic Workflow:**
1. **Write Tests First** - Create tests for all transformation scenarios
2. **Make It Green** - Implement transformations to pass tests
3. **Refactor** - Optimize for performance and maintainability

## Tasks / Subtasks

### Task 0: Write Transformation Tests FIRST (TDD Step 1)
- [ ] Create test file `src/lib/services/__tests__/transformationBridgeService.test.ts`
- [ ] Write round-trip transformation tests:
  ```typescript
  describe('Round-trip transformations', () => {
    it('should preserve all data in config→ingredient→config', () => {
      const original = mockConfig();
      const ingredient = service.configToIngredient(original);
      const result = service.ingredientToConfig(ingredient);
      expect(result).toEqual(original);
    });
    
    it('should preserve all data in ingredient→config→ingredient', () => {
      const original = mockIngredient();
      const config = service.ingredientToConfig(original);
      const result = service.configToIngredient(config);
      expect(result).toEqual(original);
    });
  });
  ```
- [ ] Write backward compatibility tests
- [ ] Write performance benchmark tests
- [ ] Run tests - all should fail (Red phase)

### Task 1: Create Transformation Service Class (AC: 1, 2, 3)
- [ ] Create new file `src/lib/services/transformationBridgeService.ts`
- [ ] Import types from Stories 3.1 models (Ingredient, ConfigManifest)
- [ ] Import TPNAdvisorType, TPNAdvisorAlias, TPNAdvisorAliasMap from `src/types/tpn.ts`
- [ ] Import existing NoteTransformService for NOTE array handling
- [ ] Define TransformationBridgeService class
- [ ] Add constructor with dependency injection for NoteTransformService
- [ ] Create method signatures for all transformations
- [ ] Add alias resolution helper methods for population type mapping

### Task 2: Preserve and Enhance Existing Transformations (AC: 1)
- [ ] Review existing noteTransformService.ts patterns
- [ ] Create wrapper methods that maintain backward compatibility:
  - [ ] `configToSections(config: any): Section[]` - extracts sections from config NOTE arrays
  - [ ] `sectionsToConfig(sections: Section[], ingredientKey: string): any` - builds config format
- [ ] Ensure these methods produce identical output to current behavior
- [ ] Add deprecation comments suggesting new methods for new code

### Task 3: Implement Ingredient to Config Transformation (AC: 2)
- [ ] Create `ingredientToConfig(ingredient: Ingredient): any`
  - [ ] Map ingredient.id to KEYNAME
  - [ ] Map ingredient.displayName to DISPLAY
  - [ ] Map ingredient.category to TYPE
  - [ ] Transform sections to NOTE array using noteTransformService
  - [ ] Handle variants by selecting appropriate population data
  - [ ] Include all required config fields (UOM_DISP, OSMO_RATIO, etc.)
- [ ] Create `ingredientToConfigWithPopulation(ingredient: Ingredient, population: TPNAdvisorType | TPNAdvisorAlias): any`
  - [ ] Apply population-specific variant overrides
  - [ ] Handle alias resolution (e.g., 'infant' → 'NEO', 'pediatric' → ['CHILD', 'ADOLESCENT'])
  - [ ] Merge base ingredient with variant data
  - [ ] Return population-specific config
- [ ] Create `ingredientToConfigWithMultiplePopulations(ingredient: Ingredient, populations: TPNAdvisorType[]): any[]`
  - [ ] Generate config for multiple population types
  - [ ] Handle special case for 'pediatric' alias that maps to multiple types
  - [ ] Return array of population-specific configs

### Task 4: Implement Config to Ingredient Extraction (AC: 3)
- [ ] Create `configToIngredient(config: any): Ingredient`
  - [ ] Extract id from KEYNAME (lowercase, hyphenated)
  - [ ] Map DISPLAY to displayName
  - [ ] Map TYPE to category
  - [ ] Convert NOTE array to sections using noteTransformService
  - [ ] Extract test cases if present in config
  - [ ] Initialize empty variants map with TPNAdvisorType keys
  - [ ] Create metadata with import timestamp
- [ ] Create `extractIngredientFromConfigs(configs: any[], deduplicte: boolean = true): Ingredient[]`
  - [ ] Process multiple configs to extract unique ingredients
  - [ ] Use content hashing for deduplication if enabled
  - [ ] Merge population-specific data into variants using TPNAdvisorType keys
  - [ ] Handle population type normalization (map legacy names to new TPNAdvisorType)
  - [ ] Return array of unique ingredients
- [ ] Create `extractIngredientWithPopulationMapping(config: any, populationType: TPNAdvisorType): Ingredient`
  - [ ] Extract ingredient with specific population variant
  - [ ] Map legacy population names to TPNAdvisorType
  - [ ] Handle alias resolution for backward compatibility

### Task 5: Implement Round-Trip Validation (AC: 4)
- [ ] Create `validateRoundTrip(original: any): ValidationResult`
  - [ ] Transform config → ingredient → config
  - [ ] Compare original with result
  - [ ] Return validation result with differences
- [ ] Create `validateIngredientRoundTrip(original: Ingredient): ValidationResult`
  - [ ] Transform ingredient → config → ingredient
  - [ ] Compare all fields for data loss
  - [ ] Flag any fields that couldn't be preserved
- [ ] Add unit tests for round-trip validation
  - [ ] Test with minimal configs
  - [ ] Test with complex configs (multiple NOTEs, all fields)
  - [ ] Test with ingredients having variants

### Task 6: Optimize Performance (AC: 5)
- [ ] Add caching layer for frequently transformed items
  - [ ] Create LRU cache with configurable size
  - [ ] Cache key based on content hash
  - [ ] Invalidate on data changes
- [ ] Optimize NOTE array processing
  - [ ] Batch process multiple sections
  - [ ] Minimize object creation in loops
- [ ] Add performance metrics
  - [ ] Log transformation times in debug mode
  - [ ] Track cache hit rates
  - [ ] Identify slow transformations

### Task 7: Handle Special Cases and Edge Cases
- [ ] Handle missing or null fields gracefully
  - [ ] Provide sensible defaults
  - [ ] Log warnings for missing required fields
- [ ] Support legacy config formats
  - [ ] Detect old format versions
  - [ ] Apply appropriate migrations
  - [ ] Handle legacy population type names (map to TPNAdvisorType)
- [ ] Handle malformed data
  - [ ] Validate input structure
  - [ ] Return detailed error messages
  - [ ] Never throw on bad data - return partial results
- [ ] Handle population type aliases
  - [ ] Support 'infant' → 'NEO' mapping
  - [ ] Support 'pediatric' → ['CHILD', 'ADOLESCENT'] multi-mapping
  - [ ] Provide fallback for unknown population types

### Task 8: Create Integration Tests
- [ ] Create test file `src/lib/services/__tests__/transformationBridgeService.test.ts`
- [ ] Test with real config examples from refs/ directory
- [ ] Test edge cases:
  - [ ] Empty configs
  - [ ] Configs with only NOTE arrays
  - [ ] Ingredients without sections
  - [ ] Complex nested structures
- [ ] Test population type transformations:
  - [ ] Legacy population names to TPNAdvisorType mapping
  - [ ] Alias resolution ('infant' → 'NEO', 'pediatric' → ['CHILD', 'ADOLESCENT'])
  - [ ] Multi-population config generation
- [ ] Verify TPN calculation engine compatibility
- [ ] Test performance with large datasets

## Dev Notes

### Architecture Context

**Existing Transformation Service**
[Source: src/lib/services/noteTransformService.ts]
```typescript
// Already handles NOTE array ↔ Section transformations
sectionsToNoteArray(sections: Section[]): NoteObject[]
noteArrayToSections(noteArray: NoteObject[], ingredientKey: string): Section[]
```
This service already exists and handles the NOTE-to-Section transformation. We'll build on top of it.

**Config Structure from Schema**
[Source: refs/schema.txt & refs/child-build-main-choc.json]
```javascript
{
  "INGREDIENT": [
    {
      "KEYNAME": "Calcium",
      "DISPLAY": "Calcium",
      "TYPE": "Micronutrient",
      "UOM_DISP": "mEq/kg/day",
      "NOTE": [
        { "TEXT": "content here" }
      ],
      // ... other fields
    }
  ]
}
```

**Ingredient Structure from Story 3.1**
[Source: Story 3.1 - models/ingredient.ts]
```typescript
interface Ingredient {
  id: string;              // "calcium"
  keyname: string;         // "Calcium"
  displayName: string;     // "Calcium"
  category: string;        // "Micronutrient"
  sections: Section[];     // Direct storage
  tests: TestCase[];       // Direct storage
  variants: Record<TPNAdvisorType, PopulationVariant>;
  metadata: IngredientMetadata;
}
```

**Content Hashing for Deduplication**
[Source: src/lib/contentHashing.ts]
- `generateIngredientHash(ingredient)` - Creates hash for deduplication
- `findDuplicates(ingredients)` - Identifies duplicate content
- Reuse these utilities for deduplication logic

**Population Types**
[Source: src/types/tpn.ts]
```typescript
export type TPNAdvisorType = 'NEO' | 'CHILD' | 'ADOLESCENT' | 'ADULT';

export type TPNAdvisorAlias = 'neonatal' | 'child' | 'adolescent' | 'adult' | 'infant';

export interface TPNAdvisorAliasMap {
  readonly infant: 'NEO';
  readonly neonatal: 'NEO';
  readonly child: 'CHILD';
  readonly adolescent: 'ADOLESCENT';
  readonly adult: 'ADULT';
  // Note: 'pediatric' would map to both CHILD and ADOLESCENT
  readonly pediatric: 'CHILD' | 'ADOLESCENT';
}
```

**TPN Advisor Mapping**
- **NEO**: Neonatal advisor (aliases: 'neonatal', 'infant')
- **CHILD**: Child advisor (alias: 'child')
- **ADOLESCENT**: Adolescent advisor (alias: 'adolescent') 
- **ADULT**: Adult advisor (alias: 'adult')
- **Special case**: 'pediatric' maps to both CHILD and ADOLESCENT

### Transformation Mappings

**Config → Ingredient Field Mappings:**
- KEYNAME → id (lowercase, hyphenated)
- KEYNAME → keyname (preserve original)
- DISPLAY → displayName
- TYPE → category
- NOTE[] → sections[] (via noteTransformService)
- UOM_DISP → metadata.uomDisplay
- OSMO_RATIO → metadata.osmoRatio
- PRECISION → metadata.precision
- REFERENCE_RANGE → metadata.referenceRanges

**Ingredient → Config Field Mappings:**
- id → KEYNAME (uppercase first letter)
- displayName → DISPLAY
- category → TYPE
- sections[] → NOTE[] (via noteTransformService)
- metadata.* → corresponding config fields
- variants[population] → applied when specific population requested

### Testing Standards

[Source: Project conventions]
- Test files in `__tests__` directories
- Use Vitest for testing
- Mock external dependencies
- Focus on transformation accuracy
- Test round-trip fidelity

### Important Notes

**Backward Compatibility Critical:**
The user specifically wants to keep transformation functions as they're useful for quickly testing ingredients in config format. This service bridges both worlds.

**From Previous Stories:**
- Story 3.1 defines the type structures
- Story 3.2 creates the IngredientService for persistence
- This story (3.3) enables conversion between the two models

**Performance Considerations:**
- Transformations will be called frequently
- Caching is important for repeated transformations
- Batch operations should be optimized

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-31 | 1.0 | Initial story creation from Epic 3 PRD | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used
*To be populated*

### Debug Log References
*To be populated*

### Completion Notes List
*To be populated*

### File List
*To be populated*

## QA Results

*To be populated after implementation*