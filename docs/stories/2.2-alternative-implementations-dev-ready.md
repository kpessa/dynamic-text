# Story 2.2: Alternative Code Implementations - DEVELOPER HANDOFF

## 🎯 Story Goal
**As a** content developer  
**I want** to see alternative implementations of my dynamic code  
**So that** I can choose the most readable, efficient, or appropriate version

## 📋 Pre-Implementation Checklist
- [ ] Review existing Gemini API integration in `api/generate-tests.js`
- [ ] Understand test runner implementation in `src/App.svelte`
- [ ] Check modal patterns (TestGeneratorModal, AIWorkflowInspector)
- [ ] Review CodeMirror setup for syntax highlighting

## 🔧 Implementation Steps

### Step 1: Create Alternative Generation API Endpoint
Create `api/generate-alternatives.js`:
```javascript
import { GoogleGenerativeAI } from '@google/generative-ai';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { code, context, style = 'all' } = req.body;
  const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

  const prompt = `
    Generate alternative implementations for this JavaScript code.
    Original code: ${code}
    Context: TPN calculation in medical advisor system
    Available via me object: ${JSON.stringify(context.ingredients || [])}
    
    Generate alternatives in these styles:
    1. Concise/Functional style
    2. Verbose/Readable style  
    3. Modern ES6+ style
    
    CRITICAL: All alternatives MUST produce EXACTLY the same output.
    Return as JSON array with {style, code, description} objects.
  `;

  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
    const result = await model.generateContent(prompt);
    const alternatives = JSON.parse(result.response.text());
    
    res.status(200).json({ alternatives });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}
```

### Step 2: Create Alternatives Modal Component
Create `src/components/AlternativesModal.svelte`:
```svelte
<script>
  import { createEventDispatcher } from 'svelte';
  import CodeEditor from '$lib/CodeEditor.svelte';
  
  let { 
    show = $bindable(),
    originalCode,
    alternatives = [],
    testCases = []
  } = $props();
  
  const dispatch = createEventDispatcher();
  let selectedIndex = $state(0);
  let validationResults = $state([]);
  
  $effect(() => {
    if (alternatives.length > 0) {
      validateAlternatives();
    }
  });
  
  async function validateAlternatives() {
    validationResults = await Promise.all(
      alternatives.map(alt => validateCode(alt.code, testCases))
    );
  }
  
  function selectAlternative(index) {
    dispatch('select', alternatives[index]);
    show = false;
  }
</script>

{#if show}
  <div class="modal-backdrop" onclick={() => show = false}>
    <div class="modal-content" onclick={(e) => e.stopPropagation()}>
      <h2>Alternative Implementations</h2>
      
      <div class="alternatives-grid">
        <div class="original-section">
          <h3>Current Implementation</h3>
          <CodeEditor value={originalCode} readonly />
        </div>
        
        {#each alternatives as alt, i}
          <div class="alternative-section" class:selected={selectedIndex === i}>
            <div class="alt-header">
              <h3>{alt.style}</h3>
              {#if validationResults[i]?.valid}
                <span class="validation-badge success">✓ Valid</span>
              {:else}
                <span class="validation-badge error">✗ Invalid</span>
              {/if}
            </div>
            <p class="alt-description">{alt.description}</p>
            <CodeEditor value={alt.code} readonly />
            <button 
              class="use-button"
              onclick={() => selectAlternative(i)}
              disabled={!validationResults[i]?.valid}
            >
              Use This Implementation
            </button>
          </div>
        {/each}
      </div>
      
      <button class="close-button" onclick={() => show = false}>Close</button>
    </div>
  </div>
{/if}

<style>
  .modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
  }
  
  .modal-content {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    max-width: 90vw;
    max-height: 90vh;
    overflow: auto;
  }
  
  .alternatives-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 20px;
    margin: 20px 0;
  }
  
  .alternative-section {
    border: 1px solid #e5e7eb;
    padding: 15px;
    border-radius: 6px;
  }
  
  .alternative-section.selected {
    border-color: #3b82f6;
  }
  
  .alt-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .validation-badge {
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 12px;
  }
  
  .validation-badge.success {
    background: #10b981;
    color: white;
  }
  
  .validation-badge.error {
    background: #ef4444;
    color: white;
  }
  
  .use-button {
    width: 100%;
    padding: 8px;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 10px;
  }
  
  .use-button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }
</style>
```

### Step 3: Add Alternatives Button to Dynamic Sections
In `src/App.svelte`, add to dynamic section header:
```svelte
<script>
  import AlternativesModal from './components/AlternativesModal.svelte';
  
  let showAlternativesModal = $state(false);
  let currentAlternatives = $state([]);
  let alternativeSectionIndex = $state(-1);
  
  async function requestAlternatives(sectionIndex) {
    const section = sections[sectionIndex];
    if (section.type !== 'dynamic') return;
    
    try {
      const response = await fetch('/api/generate-alternatives', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          code: section.content,
          context: {
            ingredients: extractIngredients(section.content)
          }
        })
      });
      
      const data = await response.json();
      currentAlternatives = data.alternatives;
      alternativeSectionIndex = sectionIndex;
      showAlternativesModal = true;
    } catch (error) {
      showNotification(`Error: ${error.message}`, 'error');
    }
  }
  
  function handleAlternativeSelect(event) {
    const alternative = event.detail;
    sections[alternativeSectionIndex].content = alternative.code;
    showNotification('Alternative implementation applied', 'success');
  }
</script>

<!-- In the dynamic section header -->
{#if section.type === 'dynamic'}
  <button 
    class="alternatives-btn"
    onclick={() => requestAlternatives(index)}
    title="Get alternative implementations"
  >
    <Icon name="code-branch" /> Alternatives
  </button>
{/if}

<!-- Add modal component -->
<AlternativesModal 
  bind:show={showAlternativesModal}
  originalCode={sections[alternativeSectionIndex]?.content}
  alternatives={currentAlternatives}
  testCases={sections[alternativeSectionIndex]?.testCases || []}
  onselect={handleAlternativeSelect}
/>
```

### Step 4: Implement Code Validation
Add to `src/lib/services/codeValidationService.js`:
```javascript
export async function validateCode(code, testCases) {
  if (!testCases || testCases.length === 0) {
    return { valid: true, message: 'No test cases to validate' };
  }
  
  for (const testCase of testCases) {
    try {
      // Create sandbox environment
      const sandbox = {
        me: {
          getValue: (key) => testCase.variables[key] || 0
        }
      };
      
      // Execute code in sandbox
      const func = new Function('me', code);
      const result1 = func(sandbox.me);
      
      // Compare with expected output if provided
      if (testCase.expectedOutput) {
        if (result1 !== testCase.expectedOutput) {
          return { 
            valid: false, 
            message: `Test "${testCase.name}" failed` 
          };
        }
      }
    } catch (error) {
      return { 
        valid: false, 
        message: `Execution error: ${error.message}` 
      };
    }
  }
  
  return { valid: true, message: 'All tests passed' };
}
```

### Step 5: Add Caching Layer
Create `src/lib/services/alternativesCache.js`:
```javascript
const cache = new Map();
const CACHE_TTL = 1000 * 60 * 60; // 1 hour

export function getCached(codeHash) {
  const entry = cache.get(codeHash);
  if (entry && Date.now() - entry.timestamp < CACHE_TTL) {
    return entry.alternatives;
  }
  return null;
}

export function setCache(codeHash, alternatives) {
  cache.set(codeHash, {
    alternatives,
    timestamp: Date.now()
  });
}

export function hashCode(code) {
  return btoa(code).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
}
```

## 🧪 Testing Instructions

### Manual Testing
1. **Generate Alternatives**:
   - Create dynamic section with simple code
   - Click "Alternatives" button
   - Verify 2-3 alternatives appear

2. **Validation**:
   - Add test case to section
   - Generate alternatives
   - Verify valid alternatives show green badge

3. **Replace Code**:
   - Select an alternative
   - Verify code is replaced
   - Run tests to confirm functionality

4. **Error Handling**:
   - Disconnect network
   - Click alternatives
   - Verify error message

### Automated Testing
Create `src/components/__tests__/AlternativesModal.test.js`:
```javascript
import { describe, it, expect } from 'vitest';
import { render, fireEvent } from '@testing-library/svelte';
import AlternativesModal from '../AlternativesModal.svelte';

describe('AlternativesModal', () => {
  it('displays alternatives', () => {
    const { getByText } = render(AlternativesModal, {
      show: true,
      originalCode: 'const x = 1',
      alternatives: [
        { style: 'Functional', code: 'const x = 1', description: 'Test' }
      ]
    });
    expect(getByText('Functional')).toBeTruthy();
  });
});
```

## 📦 Files to Modify/Create
1. ✅ Create: `api/generate-alternatives.js`
2. ✅ Create: `src/components/AlternativesModal.svelte`
3. ✅ Modify: `src/App.svelte` (add button and integration)
4. ✅ Create: `src/lib/services/codeValidationService.js`
5. ✅ Create: `src/lib/services/alternativesCache.js`
6. ✅ Create: Test files

## ⚠️ Edge Cases to Handle
- No internet connection
- Invalid/incomplete code
- Code with external dependencies
- Very long code blocks
- No test cases available
- API rate limiting

## 🎯 Definition of Done
- [ ] Alternatives button on dynamic sections
- [ ] Modal shows 2-3 alternatives
- [ ] Validation badges show correctness
- [ ] One-click replacement works
- [ ] Caching reduces API calls
- [ ] Error handling with notifications
- [ ] Tests pass

## 🚀 MVP Delivery
Focus on:
1. Single alternative generation
2. Basic validation
3. Simple replacement

Defer:
- Multiple style options
- Performance metrics
- Diff view

## 💡 Developer Notes
- Reuse TestGeneratorModal patterns
- Cache using code hash to avoid duplicate API calls
- Validate against actual test runner logic
- Consider loading state while generating
- Match existing modal styling