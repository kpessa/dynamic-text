# Story 3.2: Implement Ingredient Service Layer

## Status
Ready for Development

## Story
**As a** developer,
**I want** to create service classes for ingredient CRUD operations,
**So that** we can manage ingredients as first-class entities with direct content editing

## Acceptance Criteria
1. IngredientService with methods for create, read, update, delete
2. Direct section/test editing methods without transformation
3. Variant management for population-specific differences
4. Proper error handling and validation
5. Firebase Firestore integration for persistence

## TDD Approach
**Following TDD Agentic Workflow:**
1. **Write Tests First** - Create comprehensive test suite for all service methods
2. **Make It Green** - Implement minimum code to pass tests
3. **Refactor** - Optimize service for performance and clarity

## Tasks / Subtasks

### Task 0: Write Service Tests FIRST (TDD Step 1)
- [ ] Create test file `src/lib/services/__tests__/ingredientService.test.ts`
- [ ] Write CRUD operation tests:
  ```typescript
  describe('IngredientService CRUD', () => {
    it('should create ingredient and return id', async () => {
      const ingredient = mockIngredient();
      const id = await service.create(ingredient);
      expect(id).toBeDefined();
      expect(typeof id).toBe('string');
    });
    
    it('should retrieve ingredient by id', async () => {
      const retrieved = await service.get('calcium');
      expect(retrieved).toHaveProperty('sections');
      expect(retrieved).toHaveProperty('tests');
    });
    
    it('should handle not found gracefully', async () => {
      const result = await service.get('non-existent');
      expect(result).toBeNull();
    });
  });
  ```
- [ ] Write section/test editing tests
- [ ] Write variant management tests
- [ ] Write error handling tests
- [ ] Mock Firebase operations
- [ ] Run tests - all should fail (Red phase)

### Task 1: Create IngredientService Class Structure (AC: 1)
- [ ] Create new file `src/lib/services/ingredientService.ts`
- [ ] Import Ingredient types from `src/lib/models/ingredient.ts` (from Story 3.1)
- [ ] Define IngredientService class with private Firestore instance
- [ ] Implement constructor with Firebase initialization
- [ ] Add private helper for collection reference: `collection(db, 'ingredients')`
- [ ] Create method signatures for CRUD operations

### Task 2: Implement Basic CRUD Operations (AC: 1, 5)
- [ ] Implement `async create(ingredient: Ingredient): Promise<string>`
  - [ ] Validate ingredient data structure
  - [ ] Generate ID from keyname (lowercase, hyphenated)
  - [ ] Add serverTimestamp for createdAt/updatedAt
  - [ ] Use setDoc to create with specific ID
- [ ] Implement `async get(id: string): Promise<Ingredient | null>`
  - [ ] Use getDoc with error handling
  - [ ] Return null if not found
- [ ] Implement `async update(id: string, updates: Partial<Ingredient>): Promise<void>`
  - [ ] Use updateDoc with merge option
  - [ ] Update timestamp automatically
- [ ] Implement `async delete(id: string): Promise<void>`
  - [ ] Check for usage in configs before deletion
  - [ ] Use deleteDoc with confirmation

### Task 3: Implement Direct Section/Test Editing (AC: 2)
- [ ] Create `async updateSections(id: string, sections: Section[]): Promise<void>`
  - [ ] Update only sections field without affecting other data
  - [ ] Validate section structure before saving
  - [ ] Maintain section IDs for consistency
- [ ] Create `async updateTests(id: string, tests: TestCase[]): Promise<void>`
  - [ ] Update only tests field
  - [ ] Validate test case structure
  - [ ] Preserve test IDs
- [ ] Create `async addSection(id: string, section: Section): Promise<void>`
  - [ ] Append to existing sections array
  - [ ] Generate unique section ID
- [ ] Create `async addTest(id: string, test: TestCase): Promise<void>`
  - [ ] Append to existing tests array
  - [ ] Generate unique test ID

### Task 4: Implement Variant Management (AC: 3)
- [ ] Create `async addVariant(id: string, population: TPNAdvisorType, variant: PopulationVariant): Promise<void>`
  - [ ] Add or update variant for specific population
  - [ ] Validate population type against TPNAdvisorType
  - [ ] Support alias resolution (e.g., 'infant' → 'NEO', 'pediatric' → ['CHILD', 'ADOLESCENT'])
  - [ ] Merge with existing variants
- [ ] Create `async getVariant(id: string, population: TPNAdvisorType | TPNAdvisorAlias): Promise<PopulationVariant | null>`
  - [ ] Retrieve specific variant data
  - [ ] Handle alias resolution automatically
  - [ ] Return null if variant doesn't exist
- [ ] Create `async removeVariant(id: string, population: TPNAdvisorType | TPNAdvisorAlias): Promise<void>`
  - [ ] Remove specific population variant
  - [ ] Handle alias resolution for removal
  - [ ] Keep other variants intact
- [ ] Create `async getVariantsForAlias(id: string, alias: 'pediatric'): Promise<PopulationVariant[]>`
  - [ ] Special method for 'pediatric' alias that returns both CHILD and ADOLESCENT variants
  - [ ] Return array of variants for multi-mapping aliases

### Task 5: Implement Query and List Operations (AC: 1)
- [ ] Create `async list(filters?: IngredientFilters): Promise<Ingredient[]>`
  - [ ] Support filtering by category, name pattern
  - [ ] Use Firestore query with where clauses
  - [ ] Order by displayName by default
- [ ] Create `async search(searchTerm: string): Promise<Ingredient[]>`
  - [ ] Search in displayName and keyname fields
  - [ ] Return matches ordered by relevance
- [ ] Create `async getByCategory(category: string): Promise<Ingredient[]>`
  - [ ] Query by ingredient category field
  - [ ] Use existing category types from schema

### Task 6: Add Error Handling and Validation (AC: 4)
- [ ] Create custom error classes: `IngredientNotFoundError`, `ValidationError`
- [ ] Add validation method `private validateIngredient(ingredient: Partial<Ingredient>): void`
  - [ ] Check required fields (id, keyname, displayName)
  - [ ] Validate section structure
  - [ ] Validate test structure
- [ ] Wrap all Firebase operations in try-catch blocks
- [ ] Provide meaningful error messages for debugging
- [ ] Add logging for operations (using console.log for now)

### Task 7: Create Real-time Subscription Support
- [ ] Create `subscribe(id: string, callback: (ingredient: Ingredient) => void): Unsubscribe`
  - [ ] Use onSnapshot for real-time updates
  - [ ] Return unsubscribe function
- [ ] Create `subscribeToList(callback: (ingredients: Ingredient[]) => void): Unsubscribe`
  - [ ] Subscribe to entire ingredients collection
  - [ ] Handle incremental updates efficiently

### Task 8: Add Unit Tests
- [ ] Create test file `src/lib/services/__tests__/ingredientService.test.ts`
- [ ] Mock Firebase operations
- [ ] Test CRUD operations with valid/invalid data
- [ ] Test section/test editing methods
- [ ] Test variant management
- [ ] Test error scenarios

## Dev Notes

### Architecture Context

**Service Layer Pattern**
[Source: architecture/4-architecture-patterns.md#service-layer-pattern]
```typescript
export interface ServiceInterface {
  async operation(): Promise<Result>
  get state(): StateType
  onStateChange(callback: (state) => void): void
}
```

**Firebase Integration**
[Source: src/lib/firebase.ts]
- Firebase is already initialized in `src/lib/firebase.ts`
- Import `db` from firebase.ts for Firestore instance
- Use `COLLECTIONS` constant if available, or create new one for 'ingredients'

**Existing Firebase Patterns**
[Source: src/lib/firebaseDataService.ts]
```typescript
import { 
  collection, doc, setDoc, getDoc, getDocs,
  updateDoc, deleteDoc, query, where, 
  orderBy, onSnapshot, serverTimestamp
} from 'firebase/firestore';
```
- Follow similar import pattern for consistency
- Use serverTimestamp() for timestamps
- Follow existing error handling patterns

**Type Definitions from Story 3.1**
[Source: To be created in Story 3.1]
- Import Ingredient interface from `src/lib/models/ingredient.ts`
- Import TPNAdvisorType, TPNAdvisorAlias, and TPNAdvisorAliasMap from `src/types/tpn.ts`
- Import PopulationVariant types
- Import Section and TestCase types from `src/types/section.ts`

**Population Types**
[Source: src/types/tpn.ts]
```typescript
export type TPNAdvisorType = 'NEO' | 'CHILD' | 'ADOLESCENT' | 'ADULT';

export type TPNAdvisorAlias = 'neonatal' | 'child' | 'adolescent' | 'adult' | 'infant';

export interface TPNAdvisorAliasMap {
  readonly infant: 'NEO';
  readonly neonatal: 'NEO';
  readonly child: 'CHILD';
  readonly adolescent: 'ADOLESCENT';
  readonly adult: 'ADULT';
  // Note: 'pediatric' would map to both CHILD and ADOLESCENT
  readonly pediatric: 'CHILD' | 'ADOLESCENT';
}
```

**TPN Advisor Mapping**
- **NEO**: Neonatal advisor (aliases: 'neonatal', 'infant')
- **CHILD**: Child advisor (alias: 'child')
- **ADOLESCENT**: Adolescent advisor (alias: 'adolescent') 
- **ADULT**: Adult advisor (alias: 'adult')
- **Special case**: 'pediatric' maps to both CHILD and ADOLESCENT

**Collection Structure in Firestore**
```
/ingredients (new collection)
  /{ingredientId} (document)
    - id: string
    - keyname: string
    - displayName: string
    - category: string
    - sections: Section[]
    - tests: TestCase[]
    - variants: Record<TPNAdvisorType, PopulationVariant>
    - metadata: object
    - createdAt: Timestamp
    - updatedAt: Timestamp
```

### Integration Requirements

**Coexistence with firebaseDataService**
- New service operates on `/ingredients` collection
- Existing service continues on `/configs` collection
- No shared state or conflicts between services
- Both can use same Firebase instance (`db`)

**Performance Considerations**
- Use batch operations where possible
- Implement pagination for large lists
- Cache frequently accessed ingredients locally
- Use indexes for common query patterns

### Testing Standards

[Source: Project uses Vitest based on package.json inspection]
- Test files in `__tests__` directories
- Mock Firebase operations to avoid real database calls
- Focus on business logic validation
- Test error scenarios thoroughly

### Important Notes from Previous Stories

Story 3.1 creates the type definitions this service will use. Ensure Story 3.1 is completed and types are available before implementing this service.

The existing `firebaseDataService.ts` has patterns for:
- ID normalization (formatIngredientName function)
- Content hashing for deduplication
- Batch operations
- These patterns can be reused or adapted

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-31 | 1.0 | Initial story creation from Epic 3 PRD | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used
*To be populated*

### Debug Log References
*To be populated*

### Completion Notes List
*To be populated*

### File List
*To be populated*

## QA Results

*To be populated after implementation*