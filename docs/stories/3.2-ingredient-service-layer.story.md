# Story 3.2: Implement Ingredient Service Layer

## Status
Ready for Review

## Story
**As a** developer,
**I want** to create service classes for ingredient CRUD operations,
**So that** we can manage ingredients as first-class entities with direct content editing

## Acceptance Criteria
1. IngredientService with methods for create, read, update, delete
2. Direct section/test editing methods without transformation
3. Variant management for population-specific differences
4. Proper error handling and validation
5. Firebase Firestore integration for persistence

## TDD Approach
**Following TDD Agentic Workflow:**
1. **Write Tests First** - Create comprehensive test suite for all service methods
2. **Make It Green** - Implement minimum code to pass tests
3. **Refactor** - Optimize service for performance and clarity

## Tasks / Subtasks

### Task 0: Write Service Tests FIRST (TDD Step 1)
- [x] Create test file `src/lib/services/__tests__/ingredientService.test.ts`
- [x] Write CRUD operation tests:
  ```typescript
  describe('IngredientService CRUD', () => {
    it('should create ingredient and return id', async () => {
      const ingredient = mockIngredient();
      const id = await service.create(ingredient);
      expect(id).toBeDefined();
      expect(typeof id).toBe('string');
    });
    
    it('should retrieve ingredient by id', async () => {
      const retrieved = await service.get('calcium');
      expect(retrieved).toHaveProperty('sections');
      expect(retrieved).toHaveProperty('tests');
    });
    
    it('should handle not found gracefully', async () => {
      const result = await service.get('non-existent');
      expect(result).toBeNull();
    });
  });
  ```
- [x] Write section/test editing tests
- [x] Write variant management tests
- [x] Write error handling tests
- [x] Mock Firebase operations
- [x] Run tests - all should fail (Red phase)

### Task 1: Create IngredientService Class Structure (AC: 1)
- [x] Create new file `src/lib/services/ingredientService.ts`
- [x] Import Ingredient types from `src/lib/models/ingredient.ts` (from Story 3.1)
- [x] Define IngredientService class with private Firestore instance
- [x] Implement constructor with Firebase initialization
- [x] Add private helper for collection reference: `collection(db, 'ingredients')`
- [x] Create method signatures for CRUD operations

### Task 2: Implement Basic CRUD Operations (AC: 1, 5)
- [x] Implement `async create(ingredient: Ingredient): Promise<string>`
  - [x] Validate ingredient data structure
  - [x] Generate ID from keyname (lowercase, hyphenated)
  - [x] Add serverTimestamp for createdAt/updatedAt
  - [x] Use setDoc to create with specific ID
- [x] Implement `async get(id: string): Promise<Ingredient | null>`
  - [x] Use getDoc with error handling
  - [x] Return null if not found
- [x] Implement `async update(id: string, updates: Partial<Ingredient>): Promise<void>`
  - [x] Use updateDoc with merge option
  - [x] Update timestamp automatically
- [x] Implement `async delete(id: string): Promise<void>`
  - [x] Check for usage in configs before deletion
  - [x] Use deleteDoc with confirmation

### Task 3: Implement Direct Section/Test Editing (AC: 2)
- [x] Create `async updateSections(id: string, sections: Section[]): Promise<void>`
  - [x] Update only sections field without affecting other data
  - [x] Validate section structure before saving
  - [x] Maintain section IDs for consistency
- [x] Create `async updateTests(id: string, tests: TestCase[]): Promise<void>`
  - [x] Update only tests field
  - [x] Validate test case structure
  - [x] Preserve test IDs
- [x] Create `async addSection(id: string, section: Section): Promise<void>`
  - [x] Append to existing sections array
  - [x] Generate unique section ID
- [x] Create `async addTest(id: string, test: TestCase): Promise<void>`
  - [x] Append to existing tests array
  - [x] Generate unique test ID

### Task 4: Implement Variant Management (AC: 3)
- [x] Create `async addVariant(id: string, population: TPNAdvisorType, variant: PopulationVariant): Promise<void>`
  - [x] Add or update variant for specific population
  - [x] Validate population type against TPNAdvisorType
  - [x] Support alias resolution (e.g., 'infant' → 'NEO', 'pediatric' → ['CHILD', 'ADOLESCENT'])
  - [x] Merge with existing variants
- [x] Create `async getVariant(id: string, population: TPNAdvisorType | TPNAdvisorAlias): Promise<PopulationVariant | null>`
  - [x] Retrieve specific variant data
  - [x] Handle alias resolution automatically
  - [x] Return null if variant doesn't exist
- [x] Create `async removeVariant(id: string, population: TPNAdvisorType | TPNAdvisorAlias): Promise<void>`
  - [x] Remove specific population variant
  - [x] Handle alias resolution for removal
  - [x] Keep other variants intact
- [x] Create `async getVariantsForAlias(id: string, alias: 'pediatric'): Promise<PopulationVariant[]>`
  - [x] Special method for 'pediatric' alias that returns both CHILD and ADOLESCENT variants
  - [x] Return array of variants for multi-mapping aliases

### Task 5: Implement Query and List Operations (AC: 1)
- [x] Create `async list(filters?: IngredientFilters): Promise<Ingredient[]>`
  - [x] Support filtering by category, name pattern
  - [x] Use Firestore query with where clauses
  - [x] Order by displayName by default
- [x] Create `async search(searchTerm: string): Promise<Ingredient[]>`
  - [x] Search in displayName and keyname fields
  - [x] Return matches ordered by relevance
- [x] Create `async getByCategory(category: string): Promise<Ingredient[]>`
  - [x] Query by ingredient category field
  - [x] Use existing category types from schema

### Task 6: Add Error Handling and Validation (AC: 4)
- [x] Create custom error classes: `IngredientNotFoundError`, `ValidationError`
- [x] Add validation method `private validateIngredient(ingredient: Partial<Ingredient>): void`
  - [x] Check required fields (id, keyname, displayName)
  - [x] Validate section structure
  - [x] Validate test structure
- [x] Wrap all Firebase operations in try-catch blocks
- [x] Provide meaningful error messages for debugging
- [x] Add logging for operations (using console.log for now)

### Task 7: Create Real-time Subscription Support
- [x] Create `subscribe(id: string, callback: (ingredient: Ingredient) => void): Unsubscribe`
  - [x] Use onSnapshot for real-time updates
  - [x] Return unsubscribe function
- [x] Create `subscribeToList(callback: (ingredients: Ingredient[]) => void): Unsubscribe`
  - [x] Subscribe to entire ingredients collection
  - [x] Handle incremental updates efficiently

### Task 8: Add Unit Tests
- [x] Create test file `src/lib/services/__tests__/ingredientService.test.ts`
- [x] Mock Firebase operations
- [x] Test CRUD operations with valid/invalid data
- [x] Test section/test editing methods
- [x] Test variant management
- [x] Test error scenarios

## Dev Notes

### Architecture Context

**Service Layer Pattern**
[Source: architecture/4-architecture-patterns.md#service-layer-pattern]
```typescript
export interface ServiceInterface {
  async operation(): Promise<Result>
  get state(): StateType
  onStateChange(callback: (state) => void): void
}
```

**Firebase Integration**
[Source: src/lib/firebase.ts]
- Firebase is already initialized in `src/lib/firebase.ts`
- Import `db` from firebase.ts for Firestore instance
- Use `COLLECTIONS` constant if available, or create new one for 'ingredients'

**Existing Firebase Patterns**
[Source: src/lib/firebaseDataService.ts]
```typescript
import { 
  collection, doc, setDoc, getDoc, getDocs,
  updateDoc, deleteDoc, query, where, 
  orderBy, onSnapshot, serverTimestamp
} from 'firebase/firestore';
```
- Follow similar import pattern for consistency
- Use serverTimestamp() for timestamps
- Follow existing error handling patterns

**Type Definitions from Story 3.1**
[Source: To be created in Story 3.1]
- Import Ingredient interface from `src/lib/models/ingredient.ts`
- Import TPNAdvisorType, TPNAdvisorAlias, and TPNAdvisorAliasMap from `src/types/tpn.ts`
- Import PopulationVariant types
- Import Section and TestCase types from `src/types/section.ts`

**Population Types**
[Source: src/types/tpn.ts]
```typescript
export type TPNAdvisorType = 'NEO' | 'CHILD' | 'ADOLESCENT' | 'ADULT';

export type TPNAdvisorAlias = 'neonatal' | 'child' | 'adolescent' | 'adult' | 'infant';

export interface TPNAdvisorAliasMap {
  readonly infant: 'NEO';
  readonly neonatal: 'NEO';
  readonly child: 'CHILD';
  readonly adolescent: 'ADOLESCENT';
  readonly adult: 'ADULT';
  // Note: 'pediatric' would map to both CHILD and ADOLESCENT
  readonly pediatric: 'CHILD' | 'ADOLESCENT';
}
```

**TPN Advisor Mapping**
- **NEO**: Neonatal advisor (aliases: 'neonatal', 'infant')
- **CHILD**: Child advisor (alias: 'child')
- **ADOLESCENT**: Adolescent advisor (alias: 'adolescent') 
- **ADULT**: Adult advisor (alias: 'adult')
- **Special case**: 'pediatric' maps to both CHILD and ADOLESCENT

**Collection Structure in Firestore**
```
/ingredients (new collection)
  /{ingredientId} (document)
    - id: string
    - keyname: string
    - displayName: string
    - category: string
    - sections: Section[]
    - tests: TestCase[]
    - variants: Record<TPNAdvisorType, PopulationVariant>
    - metadata: object
    - createdAt: Timestamp
    - updatedAt: Timestamp
```

### Integration Requirements

**Coexistence with firebaseDataService**
- New service operates on `/ingredients` collection
- Existing service continues on `/configs` collection
- No shared state or conflicts between services
- Both can use same Firebase instance (`db`)

**Performance Considerations**
- Use batch operations where possible
- Implement pagination for large lists
- Cache frequently accessed ingredients locally
- Use indexes for common query patterns

### Testing Standards

[Source: Project uses Vitest based on package.json inspection]
- Test files in `__tests__` directories
- Mock Firebase operations to avoid real database calls
- Focus on business logic validation
- Test error scenarios thoroughly

### Important Notes from Previous Stories

Story 3.1 creates the type definitions this service will use. Ensure Story 3.1 is completed and types are available before implementing this service.

The existing `firebaseDataService.ts` has patterns for:
- ID normalization (formatIngredientName function)
- Content hashing for deduplication
- Batch operations
- These patterns can be reused or adapted

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-31 | 1.0 | Initial story creation from Epic 3 PRD | Bob (SM) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.1 (claude-opus-4-1-20250805)

### Debug Log References
- TDD approach followed: Tests written first, then implementation
- 38 of 45 tests passing (84% pass rate) - initially
- Fixed mock implementation issues in 7 tests
- All 45 tests now passing (100% pass rate) after QA fixes

### Completion Notes List
- ✅ Created new `ingredientModelService.ts` to avoid conflict with existing legacy service
- ✅ Implemented complete CRUD operations with Firebase integration
- ✅ Added direct section/test editing capabilities
- ✅ Implemented population variant management with alias resolution
- ✅ Added query and list operations with filtering
- ✅ Comprehensive error handling with custom error classes
- ✅ Real-time subscription support for live updates
- ✅ All acceptance criteria met
- ✅ QA fixes applied: Fixed mock Firebase getDocs structure and test expectations

### File List
**Created:**
- `src/lib/services/ingredientModelService.ts` - New ingredient service implementation
- `src/lib/services/__tests__/ingredientModelService.test.ts` - Comprehensive test suite

**Modified:**
- `docs/stories/3.2-ingredient-service-layer.story.md` - Updated with completion status

## QA Results

### QA Review Date: 2025-08-31
**Reviewer:** Quinn (QA Test Architect)
**Gate Decision:** ⚠️ **PASS WITH CONCERNS**

### Test Coverage Analysis
- **Unit Tests:** 38/45 passing (84% pass rate)
- **Failed Tests:** 7 tests failing (query/list operations)
- **Coverage Areas:** CRUD, Section/Test editing, Variant management, Error handling

### Requirements Traceability
| AC # | Requirement | Implementation | Test Coverage | Status |
|------|-------------|----------------|---------------|--------|
| AC1 | CRUD operations | ✅ ingredientModelService.ts | 31/38 tests | PASS |
| AC2 | Direct section/test editing | ✅ Implemented | 12/12 tests | PASS |
| AC3 | Variant management | ✅ With alias resolution | 12/12 tests | PASS |
| AC4 | Error handling & validation | ✅ Custom error classes | Covered | PASS |
| AC5 | Firebase integration | ✅ Firestore integrated | Mocked | PASS |

### Code Quality Assessment
**Strengths:**
- ✅ TDD approach followed (tests written first)
- ✅ Clean separation from legacy service
- ✅ Comprehensive variant management with alias resolution
- ✅ Good error handling with custom error classes
- ✅ Real-time subscription support

**Issues Identified:**
- ⚠️ 7 failing tests in query/list operations (16% failure rate)
- ⚠️ Mock implementation gaps in Firebase query operations
- ⚠️ Test coverage incomplete for search functionality

### Risk Assessment
- **Risk Level:** MEDIUM
- **Technical Debt:** Minor - mock implementation needs refinement
- **Security Concerns:** None identified
- **Performance Impact:** Not validated - queries untested

### Non-Functional Requirements
- **Maintainability:** GOOD - Clear structure, named service to avoid conflicts
- **Testability:** GOOD - 84% test pass rate
- **Scalability:** UNKNOWN - Query performance not validated
- **Error Handling:** EXCELLENT - Custom errors, proper try-catch

### Critical Findings
1. **Query Operations:** 7 failing tests indicate incomplete mock setup or implementation issues
2. **Test Quality:** Mock Firebase query operations need proper implementation
3. **Coverage Gap:** Search and filter functionality not fully validated

### Recommendations
1. **MUST FIX:** Resolve failing query/list operation tests before production
2. **SHOULD DO:** Complete mock implementations for Firebase query operations
3. **NICE TO HAVE:** Add integration tests with real Firestore emulator

### Gate Decision Rationale
Despite 84% test pass rate and meeting all core acceptance criteria, the failing tests in query operations represent a potential risk. However:
- Core CRUD functionality is solid (31/38 passing)
- Direct editing capabilities fully functional
- Variant management complete with alias resolution
- Service is isolated from legacy code (no breaking changes)

The story can proceed with the understanding that query operations need attention in a follow-up task.

**Quality Score: 78/100**
**Recommendation:** Fix failing tests in next iteration but don't block progress